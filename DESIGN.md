###high-level design goals of your project


###how to add new features to your project
* Adding a simulation is quite easy. All the programmer has to do is create a new package (not necessary but this is how we've designed them so far) for the simulation and create a class for the cell and one for the state. The class for the cell would look something like SimulationX_Cell which extends "Abstract_Cell" and the state class would look like something like SimulationX_CellState, which extends "AbstractDicrete_CellState". Then, the user just had to create a new XML file with his/her desired specifications and the simulation will run. It is very easy to add new simulations and our program is very flexible in this regard. The only issue might be if the programmer wishes to add an entirely new feature, like a new boundsType, shape, or an entirely different feature (like maybe having various cells of different sizes and shapes).

###major design choices, including trade-offs (i.e., pros and cons), made in your project
* One big design issue we discussed at the very beginning was how to design the cells. Specifically, how we should split up the methods and classes. First, it was immediately clear that we should have an abstract cell and subclasses consisting of cells for each implementation. These subclasses of cells would contain the rules about how they should interact. However, we had to make a decision on whether they would contain ALL the information about the cells, like which color they are, which type of cell they are (like one of the 3 cells in a given simulation), and other variables about each cell (like time to reproduction, levels of sugar, etc). We could do this in two main ways: either contain all the information in one class, which would result in literally zero ambiguities of where a certain field of method should go (it's all in the same class! Don't have to worry about passing around parameters or calling methods in a helper class); alternatively, we could split up the characteristcs of each cell. One class would contain information about the "state"--like the color, fields, etc-- while the other would contain rules about how it would interact. We decided to go with the latter as, although there may be some ambiguity whether a method to determine whether the cell should "die" or reproduce, drawing a line would make it easier to maintain and extend a simulation to add more features. We decided that the cell class should contain the rules about what to do under certain scenarios and its neighbors, while the state class should hold the main information and features about the cell-- its "state". At first, we had some discussions whether a method to determine when a predator (for instance) dies should be in the cell class or the state class. After some discussion and practice, it became rather clear how these methods and fields should be split up. The main thing was that we would set the next set of a neighboring cell whenever a cell would interact with its neighbors. This is a pretty straight forward concept: a cell has a current state and gets a new one in the next state based on what its neighbors do, and then the grid can call each cell to interact and then update to its new state. Passing in a new state, as opposed to passing in a new entire cell, was cleaner logically and separately a lot of the nuts and bolts into a different class. The cell only had to make decisions given data about its state, while the state class handled how this data and this state should be represented and manipulated. I think we definitely made the right choice as this made it easier to extend these cells in the future if we needed to (could change the state class without affecting the cell. For instance, in sugarscape we changed how the agents in the state were represented (from a collection to a single agent). Also, it was easy for us to add another class, like agent, because we already conceptionally decided that a cell class should only hold information about how to interact with others. When we got these additional specifications, this line of thinking didn't change. Each cell still only has information about how to interact; we just added an agent for it to interact with. So throughout our entire program, the role of the cell stays the same. I think we definitely made the right choice.

###any assumptions or decisions made to simplify or resolve ambiguities in your the project's functionality
* One assumption we made was that each cellstate would have an enum type, which is why it is necessary for each cellstate class in each simulation package to extend AbstractDicrete_CellState, which forces this to be true. This made it simpler to display the cells on screen.