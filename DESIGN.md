Design.md
------------

⧸⧸
> Written with [StackEdit](https://stackedit.io/).
# Introduction
Our team is trying to implement a program that is able to simulate any 2D grid consisting of cells. The state of each cell is updated with each step, which can be sped up or slowed down. Further more, the cells need to be able to interact with each other according to a set of rules. It should be flexible enough to allow new rules and new ways of interaction to be added. Furthermore, it should be able to support any number of cells in the simulation.  Each cell must be able to track its previous and current (updated) status, which will be used for other cells to determine what their next state it. Because there are so many possibilities for how the cells react, we will have to be able describe different set of rules for each game possibility. In terms of the design architecture, the actual implementation of the cells should be closed to modification. However, the fact that each cell should be updated, be able to check its neighbors, hold a status, and all the possible actions of a cell should all be open for extension. This is because there will be different implementation of cells, but they should all have similar methods and features. 

# Overview
* The team discussed that each simulation would have a package to distinguish between each simulation. There will be a main class which would read an XML file, and launch the arguments. This would be the superclass. The CellSociety package will have an abstract class to understand what each cell is and it will also other classes to create the grid for the simulation. This is done to divide into packages, what is common between all the simulations. Lastly, there will be any amount of packages needed for each simulation that one wants to run.  In the cell society Main. It will have a method to start the simulation, an update method to update the state of each Cell and a simulation method which would read the XML file.
* In the CellSociety, there will be a cell, cellstate, SimulationGrid and a properties of the windows one is seeing class. In cell, one would get the position and the color in the simulation. cellState would be an abstract class which compares if the cell is equal to a certain state. SimulationGrid would use an nxn grid, gets the neighbor of a cell and returns them as a collection of cells. The data structure used is an array. Lastly, in properties of Windows would be used to get the width and height of the rectangle which would be a utility class. 
* The other packages will have two classes. One is Cell and the other one is CellState. The Cell class would extend CellSociety to call Cell and SimulationGrid for the interaction and set the rules of the simulation. The CellState would have the states of the simulation, fill the Color of the rectangle or grid, get the state of the cell and a compare to method to compare the same type of object.

# User Interface
* To start, everything should be done through the XML file, including choosing the type of simulation, size of the grid, speed, and the default state for the cells. It also contains all the starting positions of the living cells. Every cell is not default is written in by the user. Because our program reads the XML file as an input, we think it makes most sense for the user to control all of these aspects through the XML file.
* Further, the user will be able to press a button to stop the current simulation, which will then prompt the user to select or type in a new XML file specifying the new simulation to be run. 
* To pause the game, the user can press spacebar and to speed up and slow down, the user just presses +/-. Later on, we are planning on making this more user friendly by implementing buttons. Additionally, we could do more UI controls to determine the size of the grid, etc.
* For any erroneous errors, like not being able to read a file, we use try catch statements and print out an error to the user. We've already implemented this to some extent and plan on doing it for the big possible errors. 
* The attached picture shows what our final product may look like, along with some more buttons.

# Design Details
* Per one the use cases, for the cells on the edge, the neighbors that are not on the screen would be considered dead. This would be done in the SimulationGrid to set the ones that are not on the screen as null. Then, in the packages for each simulation, in the Cell class, in an interact method, one would say that if the method is null then it would not interact with it. This would be made so that the interaction are the ones that should be done like in Game of Life and have all the active grids in the windows.
* For the cells that are not on the edge, the neighbors would be considered “alive” so that when one uses the .getneighbors one wouldn’t get null. This would be done in the SimulationGrid method in CellSociety. Then in the packages for each simulation in the Cell class , in the interact method, one would say that if the method is alive, then it would interact and the rules of the simulation could apply. This is done to get the proper configurations for the simulation.To handle the Use Case for fire, we will include a tryCatch in the CellSocietyMain class that checks if there a value in the XML file for probCatch. If there is, the Cell class and CellState class in the Fire package will make use for running through the interactions between cells for this simulation. This is a pretty simple thing to do, and can be implemented easily within our CellSocietyMain class. 
* Next, the CellSocietyMain class is also flexible enough to allow the user to switch simulations. We've touched upon this a bit in the previous sections. The user will press a button to stop the simulation, which will then clear the read and call the readXML file again, which the user will input. This allows the user to switch from any simulation to any other simulation at any time. In order for this to work, we need to add a scenario in the handleKeyPress method in CellSocietyMain, but this will be easy to implement and we're confident we'll handle this use case without many problems. Overall, it's pretty clear how this class will be able to set up the grid and handle these different simulation scenarios. 
*  To move cells from the current generation to the next,  the CellSocietyMain class's update() method calls each cell in the simulation grid to update (meaning the abstract Cell class has an updateState() method that changes the current state to the next state, and each concrete class has an interacts() method, which determines what each cell should be in the next state). This then immediately displays the next state of each cell graphically. If we were to add a new simulation, or change any of the rules, this CellSocietyMain class would be the same, as would the abstract Cell class. The new cells would be displayed graphically no matter how we implement the actual rules of each simulation.
*  At this point, it's pretty clear how our classes will interact. Each concrete class will interact and update appropriately, with the MainCellSociety class calling each Cell to update itself. The use of an abstract Cell class makes this very easy and flexible. 



# Design Considerations
* These are several issues we've discussed when thinking about designing a complete solution. First, we discussed how to create a instance of the proper class when reading the XML file. Specifically, when the XML file is read, we create a class based on what is read via the line "Class<? extends Cell> cellType = (Class<? extends Cell>) Class.forName(currentCell.getAttribute("type") + ".Cell");" using Reflections. We did this as opposed to having several IF, ELSE statements because our way of doing so is much neater than having several IF statements, especially when there are several possible simulations to run. It is easier to read and whenever a new type of simulation is created, the programmer doesn't have to add another statement--a new XML file just needs to be read in. A con to this was that it's not very safe and we could get errors, but we think the neatness and simplicity of our design is much better.
* We also discussed implemented a data structure, like an arrayList or Linked List, to keep track of the cell states to allow us to jump forward or backward in time. We determined that an arrayList would be better as we can still add onto it in O(1) amortized time and we could jump to an index. However, we decided not to implement this at this time as it's not required, but it's an idea we had about how the program might be extended in the future to make the simulation a bit more extensive.
* We decided to have one package containing the abstract classes Cell and Cellstate, and then one package for each possible simulation, each containing their own cell and cellstate class. We decided to do this this way for a few reasons. First, this a proper use of inheritence and it makes our program very flexible if we were to add new simulations. Further, this organizes our folders in a very readable and easy-to-follow fashion. We debated just having four different classes called CellFire and CellGameOfLife, for instance, but ultimately felt organizing them in packages is easier to follow.
*  We decided to create a static class called WindowsProperties, as this allows the dimensions of the grid to be global and for other classes to access them. This is necessary because other classes need to reference the dimensions of the grid when creating new cells, etc. The alternative was to pass these values to every class, which we felt was redundant, excessive, and compromised readability.

# Team Responsibilities
Each person will be responsible for implementing Cell::interact for each of the different simulations, so each person takes one of the remaining simulations. The first person to finish will begin working on speeding up/slowing down the simulation. 
